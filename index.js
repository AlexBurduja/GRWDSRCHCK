require("dotenv").config();

const axios = require("axios");
const cheerio = require("cheerio");
const qs = require("qs");
const tough = require("tough-cookie");
const { wrapper } = require("axios-cookiejar-support");
const express = require("express");
const fs = require("fs");

const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;
const BASE_URL = "https://grawe.native-code.ro";
const LOGIN_URL = `${BASE_URL}/login.aspx`;
const TARGET_URL = `${BASE_URL}/content/files/check/file_list_check_client.aspx`;
const USERNAME = process.env.LOGIN_USERNAME;
const PASSWORD = process.env.LOGIN_PASSWORD;
const GIST_ID = process.env.GIST_ID;
const GIST_ID_NOTES = process.env.GIST_ID_NOTES
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

const COOKIE_FILE = "./cookies.json";
const META_FILE = "./cookie_meta.json";

let previousNotes = [];
let previousNoteCount = 0;
let pending2FA = false;
let saved2FACode = null;
let resumeLoginAfter2FA = null;
let timeoutHandle = null;

let globalClient = null;
let globalCookieJar = null;

const app = express();
const PORT = 3000;

const MONITORED_LIQUIDATORS = [
  { id: "507", name: "Burduja Alexandru" },
  { id: "92", name: "Agiu Ionut" },
  { id: "88", name: "Donici Alexandru" },
];

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Botul este activ.");
});

app.post(`/webhook/${TELEGRAM_TOKEN}`, async (req, res) => {
  const body = req.body;

  // üî• DacƒÉ vine un callback_query (apasƒÉ pe buton)
  if (body.callback_query) {
    const callback = body.callback_query;
    const chatId = callback.message.chat.id;
    const data = callback.data;

    if (data.startsWith("status:")) {
      const name = data.substring(7);

      // üì§ RƒÉspundem imediat la callback_query ca sƒÉ evitƒÉm blocaje
      await axios.post(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/answerCallbackQuery`, {
        callback_query_id: callback.id
      });

      // üì¨ Trimitem un mesaj de √ÆncƒÉrcare
      await sendTelegram(`üîç Am selectat: ${name}\n‚è≥ Se √ÆncarcƒÉ statusul...`, chatId);

      // üß† AICI continuƒÉm logica fƒÉrƒÉ sƒÉ mai blocƒÉm request-ul
      setTimeout(async () => {
        try {
          if (!globalClient) {
            const result = await login();
            globalClient = result.client;
          }

          const { notes, messageId } = await fetchTableDataFor(name, globalClient, chatId);

          const total = notes.length;
          const yellow = notes.filter(n => n.isYellow).length;
          const white = total - yellow;

          await editTelegram(messageId, `üìä Status pentru ${name}:\nüü° Galbene: ${yellow}\n‚úÖ Albe: ${white}\nüì¶ Total: ${total}`, chatId);
        } catch (error) {
          await sendTelegram(`‚ùå Eroare: ${error.message}`, chatId);
        }
      }, 0);
    }

    return res.sendStatus(200); // üöÄ √Ænchidem rapid request-ul ca sƒÉ nu mai reporneascƒÉ serverul!
  }

  const message = body.message;
  if (!message || !message.text) return res.sendStatus(200);

  const chatId = message.chat.id;
  const text = message.text.trim();

  if (text === "/test") {
    await sendTelegram("‚úÖ Botul func»õioneazƒÉ corect!", chatId);
  }

  if (text === "/check") {
    if (fs.existsSync(COOKIE_FILE)) {
      const cookieFile = JSON.parse(fs.readFileSync(COOKIE_FILE, "utf8"));
      const cookies = cookieFile.cookies || [];
      const cookie2FA = cookies.find(c => c.key === "2faKey");

      if (cookie2FA && cookie2FA.expires) {
        const expiryDate = new Date(cookie2FA.expires);
        const now = new Date();
        const diffMs = expiryDate - now;
        const daysLeft = Math.max(0, Math.floor(diffMs / (1000 * 60 * 60 * 24)));

        const creationDate = new Date(cookie2FA.creation);

        const ziua = creationDate.getDate().toString().padStart(2, '0');
        const luna = (creationDate.getMonth() + 1).toString().padStart(2, '0');
        const anul = creationDate.getFullYear();
        const ora = creationDate.getHours().toString().padStart(2, '0');
        const minutul = creationDate.getMinutes().toString().padStart(2, '0');
        
        const formatFinal = `${ziua}.${luna}.${anul} ${ora}:${minutul}`;

        await sendTelegram(`üîê 2FA a fost creat pe ${formatFinal} »ôi expirƒÉ √Æn ${daysLeft} zile.`, chatId);
      } else {
        await sendTelegram("‚ö†Ô∏è Cookie-ul 2FA nu a fost gƒÉsit. Probabil nu ai trecut √ÆncƒÉ prin 2FA.", chatId);
      }
    }
  }

  if (text.startsWith("/2fa ")) {
    const code = text.split(" ")[1];
    if (code && resumeLoginAfter2FA) {
      clearTimeout(timeoutHandle);
      saved2FACode = code;
      pending2FA = false;
      await sendTelegram("üîê Cod 2FA primit. ContinuƒÉm autentificarea...", chatId);
      resumeLoginAfter2FA(code);
    } else {
      await sendTelegram("‚ö†Ô∏è Nu a fost solicitat un cod 2FA sau codul este invalid.", chatId);
    }
  }

  if (text.startsWith("/status ")) {
    const name = text.substring(8).trim();
    try {
      const { notes, messageId } = await fetchTableDataFor(name, globalClient, chatId);

      const total = notes.length;
      const yellow = notes.filter(n => n.isYellow).length;
      const white = total - yellow;

      await editTelegram(messageId, `üìä Status pentru ${name}:\nüü° Galbene: ${yellow}\n‚úÖ Albe: ${white}\nüì¶ Total: ${total}`, chatId);
    } catch (error) {
      await sendTelegram(`‚ùå Eroare: ${error.message}`, chatId);
    }
  }

  if (text === "/status") {
    if (!globalClient) {
      const result = await login();
      globalClient = result.client;
    }

    const colegi = await fetchColegi(globalClient);

    const inlineKeyboard = colegi.map(nume => {
      return [{ text: nume, callback_data: `status:${nume}` }];
    });

    await axios.post(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`, {
      chat_id: chatId,
      text: "üë• Alege colegul pentru care vrei status:",
      reply_markup: { inline_keyboard: inlineKeyboard }
    });
  }

  res.sendStatus(200); // ‚ö°Ô∏è √énchidem rapid »ôi mesajele normale
});

app.listen(PORT, () => {
  console.log(`Express server is running on port ${PORT}`);
});

async function sendTelegram(msg, chatId = TELEGRAM_CHAT_ID) {
  try {
    await axios.post(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`, {
      chat_id: chatId,
      text: msg,
    });
  } catch (error) {
    console.log("Error sending Telegram message:", error.message);
  }
}

async function editTelegram(msgId, newText, chatId = TELEGRAM_CHAT_ID) {
  try {
    await axios.post(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/editMessageText`, {
      chat_id: chatId,
      message_id: msgId,
      text: newText,
    });
  } catch (error) {
    console.log("Error editing Telegram message:", error.message);
  }
}

async function uploadToGist(content) {
  if (!GIST_ID || !GITHUB_TOKEN) return;
  try {
    await axios.patch(
      `https://api.github.com/gists/${GIST_ID}`,
      {
        files: {
          "cookies.json": { content },
        },
      },
      {
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
        },
      }
    );
    console.log("üì§ Cookie uploadat √Æn GitHub Gist!");
  } catch (err) {
    console.error("‚ùå Eroare la upload √Æn Gist:", err.message);
  }
}

async function downloadFromGist() {
  if (!GIST_ID || !GITHUB_TOKEN) return null;
  try {
    const res = await axios.get(`https://api.github.com/gists/${GIST_ID}`, {
      headers: { Authorization: `token ${GITHUB_TOKEN}` },
    });
    const content = res.data.files["cookies.json"].content;
    fs.writeFileSync(COOKIE_FILE, content);
    console.log("üì• Cookie descƒÉrcat din GitHub Gist!");
    return tough.CookieJar.deserializeSync(JSON.parse(content));
  } catch (err) {
    console.error("‚ùå Eroare la descƒÉrcare din Gist:", err.message);
    return new tough.CookieJar();
  }
}

function loadCookies() {
  if (fs.existsSync(COOKIE_FILE)) {
    console.log("üç™ Cookie √ÆncƒÉrcat din cookies.json");
    const raw = fs.readFileSync(COOKIE_FILE, "utf8");
    return tough.CookieJar.deserializeSync(JSON.parse(raw));
  }

  if (process.env.COOKIES_JSON) {
    console.log("üì¶ Cookie √ÆncƒÉrcat din env (COOKIES_JSON)");
    const raw = Buffer.from(process.env.COOKIES_JSON, "base64").toString("utf8");
    fs.writeFileSync(COOKIE_FILE, raw);
    return tough.CookieJar.deserializeSync(JSON.parse(raw));
  }

  console.log("üîç √éncercƒÉm descƒÉrcarea din Gist...");
  return downloadFromGist();
}

async function saveCookies(jar) {
  const serialized = jar.serializeSync();
  const raw = JSON.stringify(serialized);
  const encoded = Buffer.from(raw).toString("base64");

  fs.writeFileSync(COOKIE_FILE, raw);
  console.log("üíæ Cookie salvat √Æn cookies.json");

  const now = new Date().toISOString();
  fs.writeFileSync(META_FILE, JSON.stringify({ loginDate: now }));
  console.log("üóìÔ∏è DatƒÉ 2FA salvatƒÉ:", now);

  await uploadToGist(raw);
  await sendTelegram(`üì¶ Cookie regenerat dupƒÉ 2FA. A fost sincronizat automat √Æn Gist.`);
}

async function saveNotesToGist(inspectorId, notes) {
  if (!GIST_ID_NOTES || !GITHUB_TOKEN) return;
  try {
    await axios.patch(
      `https://api.github.com/gists/${GIST_ID_NOTES}`,
      {
        files: {
          [`notes_${inspectorId}.json`]: {
            content: JSON.stringify(notes, null, 2),
          },
        },
      },
      {
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
        },
      }
    );
    console.log(`üíæ notes_${inspectorId}.json salvat √Æn Gist.`);
  } catch (err) {
    console.error("‚ùå Eroare la salvare notes √Æn Gist:", err.message);
  }
}

async function loadNotesFromGist(inspectorId) {
  if (!GIST_ID_NOTES || !GITHUB_TOKEN) return [];
  try {
    const res = await axios.get(`https://api.github.com/gists/${GIST_ID_NOTES}`, {
      headers: { Authorization: `token ${GITHUB_TOKEN}` },
    });

    const file = res.data.files[`notes_${inspectorId}.json`];
    if (!file) return [];

    return JSON.parse(file.content);
  } catch (err) {
    console.error("‚ùå Eroare la √ÆncƒÉrcare notes:", err.message);
    return [];
  }
}

async function login(force = false) {
  const jar = await loadCookies();
  globalCookieJar = jar;
  const client = wrapper(axios.create({ jar, withCredentials: true }));

  if (!force) {
    try {
      const test = await client.get(TARGET_URL);
      if (!test.data.includes("TextBoxPass") && !test.data.includes("Autentificare esuata")) {
        console.log("‚úÖ Folosim sesiunea salvatƒÉ.");
        return { client };
      }
    } catch (e) {
      console.warn("‚ö†Ô∏è Test GET a e»ôuat. Relogin necesar.", e.message);
    }
  }

  const loginPage = await client.get(LOGIN_URL);
  let $ = cheerio.load(loginPage.data);
  const payload = {
    __VIEWSTATE: $("#__VIEWSTATE").val(),
    __VIEWSTATEGENERATOR: $("#__VIEWSTATEGENERATOR").val(),
    __EVENTVALIDATION: $("#__EVENTVALIDATION").val(),
    __EVENTTARGET: "",
    __EVENTARGUMENT: "",
    Hidden_ClientJS: $("#Hidden_ClientJS").val() || "",
    TextBoxUser: USERNAME,
    TextBoxPass: PASSWORD,
    ButtonLogin: "Autentificare",
  };

  let response = await client.post(LOGIN_URL, qs.stringify(payload), {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Referer: LOGIN_URL,
      Origin: BASE_URL,
    },
  });

  if (response.data.includes("TextBoxCode")) {
    console.log("üì© Cod 2FA necesar ‚Äì a»ôtept prin Telegram...");
    await sendTelegram("üì© Cod 2FA necesar. Trimite-l cu comanda: /2fa CODUL_TAU");

    pending2FA = true;

    return await new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(async () => {
        await sendTelegram("‚è±Ô∏è Timpul de 10 minute pentru 2FA a expirat. Botul se va opri.");
        process.exit(1);
      }, 10 * 60 * 1000);

      resumeLoginAfter2FA = async (code) => {
        const $$ = cheerio.load(response.data);
        const codePayload = {
          __VIEWSTATE: $$('input#__VIEWSTATE').val(),
          __VIEWSTATEGENERATOR: $$('input#__VIEWSTATEGENERATOR').val(),
          __EVENTVALIDATION: $$('input#__EVENTVALIDATION').val(),
          __EVENTTARGET: "",
          __EVENTARGUMENT: "",
          Hidden_ClientJS: $$('input#Hidden_ClientJS').val() || "",
          TextBoxCode: code,
          CheckBoxDevice: "on",
          ButtonLogin: "Autentificare",
        };

        const finalResponse = await client.post(LOGIN_URL, qs.stringify(codePayload), {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Referer: LOGIN_URL,
            Origin: BASE_URL,
          },
        });

        if (finalResponse.data.includes("TextBoxPass")) {
          await sendTelegram("‚ùå Cod 2FA incorect sau autentificare e»ôuatƒÉ.");
          throw new Error("Autentificare e»ôuatƒÉ dupƒÉ 2FA");
        }

        clearTimeout(timeoutHandle);
        await sendTelegram("‚úÖ Autentificare reu»ôitƒÉ dupƒÉ 2FA!");
        saveCookies(jar);
        resolve({ client });
      };
    });
  }

  if (response.data.includes("TextBoxPass")) throw new Error("‚ùå Autentificare e»ôuatƒÉ.");

  console.log("‚úÖ Autentificare reu»ôitƒÉ!");
  saveCookies(jar);
  return { client };
}

async function fetchTableData(client, retry = true) {
  const response = await client.get(TARGET_URL);
  const $ = cheerio.load(response.data);

  const table = $("#ctl00_ContentPlaceHolderMain_TabContainer_MAIN_TabPanel_APPROVAL_LIST_GridViewApprovalList");
  if (!table.length) {
    console.warn("‚ùå Table not found.");
    if (retry) {
      console.log("üîÅ Re√ÆncercƒÉm dupƒÉ login for»õat...");
      const result = await login(true);
      globalClient = result.client;
      return await fetchTableData(globalClient, false);
    }
    return [];
  }

  const rows = table.find("tr").slice(1);
  const notes = [];

  rows.each((_, row) => {
    const $row = $(row);
    const tds = $row.find("td");
    const noteId = tds.eq(1).text().trim();

    const bgcolorAttr = $row.attr("bgcolor")?.toLowerCase() || "";
    const isYellow = bgcolorAttr === "#fff3cd";

    notes.push({ id: noteId, isYellow });
  });

  return notes;
};

async function fetchTableDataFor(name, client, chatId) {
  const sent = await axios.post(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`, {
    chat_id: chatId,
    text: `‚è≥ √éncepem analiza pentru ${name}... 0%`,
  });

  const messageId = sent.data.result.message_id;

  const response = await client.get(TARGET_URL);
  const $ = cheerio.load(response.data);

  const viewstate = $("#__VIEWSTATE").val();
  const eventvalidation = $("#__EVENTVALIDATION").val();
  const viewstategenerator = $("#__VIEWSTATEGENERATOR").val();
  const dropdownName = "ctl00$ContentPlaceHolderMain$DropDownListFilterLiquidator";
  const buttonName = "ctl00$ContentPlaceHolderMain$ButtonFilter";

  const dropdownOption = $(`select[name="${dropdownName}"] option`).filter(function () {
    return $(this).text().trim().toLowerCase() === name.trim().toLowerCase();
  }).attr("value");

  if (!dropdownOption) {
    await editTelegram(messageId, `‚ùå Nu am gƒÉsit lichidatorul ${name}.`, chatId);
    throw new Error(`‚ùå Nu am gƒÉsit lichidatorul ${name}.`);
  }

  const payload = {
    __VIEWSTATE: viewstate,
    __VIEWSTATEGENERATOR: viewstategenerator,
    __EVENTVALIDATION: eventvalidation,
    Hidden_ClientJS: $("#Hidden_ClientJS").val() || "",
    __EVENTTARGET: buttonName,
    __EVENTARGUMENT: "",
  };
  payload[dropdownName] = dropdownOption;

  const postResponse = await client.post(TARGET_URL, qs.stringify(payload), {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Referer: TARGET_URL,
      Origin: BASE_URL,
    },
  });

  const $$ = cheerio.load(postResponse.data);

  const table = $$("table#ctl00_ContentPlaceHolderMain_TabContainer_MAIN_TabPanel_APPROVAL_LIST_GridViewApprovalList");
  if (!table.length) {
    await editTelegram(messageId, `‚ùå Nu am gƒÉsit tabelul dupƒÉ filtrare.`, chatId);
    throw new Error(`‚ùå Nu am gƒÉsit tabelul dupƒÉ filtrare.`);
  }

  const rows = table.find("tr").slice(1);
  const totalRows = rows.length;
  let current = 0;

  const notes = [];

  for (const row of rows) {
    const $row = $$(row);
    const tds = $row.find("td");
    const noteId = tds.eq(1).text().trim();
    const bgcolorAttr = $row.attr("bgcolor")?.toLowerCase() || "";
    const isYellow = bgcolorAttr === "#fff3cd";

    notes.push({ id: noteId, isYellow });

    current++;
    if (current % Math.ceil(totalRows / 10) === 0 || current === totalRows) {
      const percent = Math.floor((current / totalRows) * 100);
      await editTelegram(messageId, `‚è≥ AnalizƒÉ pentru ${name}: ${percent}%`, chatId);
    }
  }

  return { notes, messageId };
};

async function fetchColegi(client) {
  const response = await client.get(TARGET_URL);
  const $ = cheerio.load(response.data);

  const colegi = [];
  const dropdownName = "ctl00$ContentPlaceHolderMain$DropDownListFilterLiquidator";

  $(`select[name="${dropdownName}"] option`).each((_, option) => {
    const name = $(option).text().trim();
    if (name && name.length > 0 && name !== "- Toate -") {
      colegi.push(name);
    }
  });

  return colegi;
}

async function checkNotes() {
  console.log("üß† Pornire checkNotes()...");

  if (!globalClient) globalClient = (await login()).client;

  let finalMessage = `üìã Rezumat actualizare dosare:\n\n`;

  for (const { id, name } of MONITORED_LIQUIDATORS) {
    console.log(`üîé Verificare pentru ${name}...`);

    const previousNotes = await loadNotesFromGist(id);

    try {
      const { notes } = await fetchTableDataFor(name, globalClient, TELEGRAM_CHAT_ID);

      const currentIds = notes.map(n => n.id);
      const previousIds = previousNotes.map(n => n.id);

      const trulyNew = notes.filter(n => !previousIds.includes(n.id));
      const disappeared = previousNotes.filter(n => !currentIds.includes(n.id));
      const turnedYellow = notes.filter(n => {
        const prev = previousNotes.find(p => p.id === n.id);
        return prev && !prev.isYellow && n.isYellow;
      });
      const becameNormal = previousNotes.filter(p => {
        const curr = notes.find(n => n.id === p.id);
        return p.isYellow && curr && !curr.isYellow;
      });

      const prevMap = new Map(previousNotes.map(n => [n.id, n]));
      const currMap = new Map(notes.map(n => [n.id, n]));

      const notesChanged =
        notes.length !== previousNotes.length ||
        [...currMap.keys()].some(id => !prevMap.has(id)) ||
        [...prevMap.keys()].some(id => !currMap.has(id)) ||
        [...currMap.keys()].some(id => {
          const prev = prevMap.get(id);
          const curr = currMap.get(id);
          return prev && curr && prev.isYellow !== curr.isYellow;
        });

      if (notesChanged) {
        finalMessage += `üìå ${name}:\n`;

        if (trulyNew.length > 0)
          finalMessage += `üì• ${trulyNew.length} noi (${trulyNew.filter(n => n.isYellow).length} galbene)\n`;

        if (disappeared.length > 0)
          finalMessage += `üóëÔ∏è ${disappeared.length} eliminate\n`;

        if (turnedYellow.length > 0)
          finalMessage += `üü° ${turnedYellow.length} au devenit galbene\n`;

        if (becameNormal.length > 0)
          finalMessage += `‚úÖ ${becameNormal.length} au redevenit normale\n`;

        finalMessage += "\n";

        await saveNotesToGist(id, notes);
        console.log(`üì® ${name}: schimbƒÉri detectate »ôi salvate.`);
      } else {
        finalMessage += `üìå ${name}: fƒÉrƒÉ modificƒÉri\n\n`;
        console.log(`üì≠ ${name}: fƒÉrƒÉ modificƒÉri.`);
      }
    } catch (err) {
      finalMessage += `‚ùå ${name}: Eroare la verificare: ${err.message}\n\n`;
    }
  }

  await sendTelegram(finalMessage.trim());
}

(async () => {
  await sendTelegram(`üîÑ Bot repornit. Se √ÆncarcƒÉ fi»ôierele individuale...`);
  await checkNotes();
  setInterval(async () => {
    console.log("‚è∞ Verificare periodicƒÉ...");
    await checkNotes();
  },5 * 60_000);
})();